// setup.sh
#!/bin/bash

# Check if claude_output.txt exists
if [ ! -f "claude_output.txt" ]; then
    echo "Error: claude_output.txt not found!"
    exit 1
fi

# Create base project directory
mkdir -p medical-transport-marketplace/{frontend,backend}/{src,public}
mkdir -p medical-transport-marketplace/frontend/src/{components,types,hooks}
mkdir -p medical-transport-marketplace/backend/src/{services,types,models}

cd medical-transport-marketplace || exit

# Read the claude_output.txt file and process it
current_file=""
{
    while IFS= read -r line || [ -n "$line" ]; do
        if [[ $line == //* ]]; then
            if [ -n "$current_file" ]; then
                exec 3>&-
            fi
            filepath=$(echo "$line" | sed 's/\/\/ *//')
            mkdir -p "$(dirname "$filepath")"
            current_file="$filepath"
            exec 3>"$current_file"
            echo "Creating $filepath..."
        else
            if [ -n "$current_file" ]; then
                echo "$line" >&3
            fi
        fi
    done
} < "../claude_output.txt"

if [ -n "$current_file" ]; then
    exec 3>&-
fi

# Make scripts executable
chmod +x run_dev.sh

echo "Project setup complete! ðŸš€"
echo "Next steps:"
echo "1. Ensure Redis is installed and running"
echo "2. cd medical-transport-marketplace"
echo "3. ./run_dev.sh"

// run_dev.sh
#!/bin/bash

# Check if Redis is running
redis-cli ping > /dev/null 2>&1
if [ $? -ne 0 ]; then
    echo "Error: Redis is not running. Please start Redis first."
    exit 1
fi

# Install dependencies if needed
echo "Installing dependencies..."
cd frontend && npm install
echo "Building TypeScript..."
npm run type-check
cd ../backend && npm install
npm run type-check

# Start backend server
echo "Starting backend server..."
cd ../backend
npm run dev &
BACKEND_PID=$!

# Start frontend dev server
echo "Starting frontend dev server..."
cd ../frontend
npm run dev &
FRONTEND_PID=$!

# Handle cleanup on script termination
cleanup() {
    echo "Shutting down servers..."
    kill $BACKEND_PID
    kill $FRONTEND_PID
    exit 0
}

trap cleanup SIGINT SIGTERM

# Keep script running
wait

// frontend/.gitignore
node_modules
dist
.env.local
.env

// backend/.gitignore
node_modules
dist
.env
*.log

// frontend/package.json
{
  "name": "medical-transport-frontend",
  "version": "1.0.0",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "lucide-react": "0.263.1",
    "recharts": "^2.10.3",
    "@radix-ui/react-slot": "^1.0.2"
  },
  "devDependencies": {
    "@types/react": "^18.2.45",
    "@types/react-dom": "^18.2.18",
    "@typescript-eslint/eslint-plugin": "^6.14.0",
    "@typescript-eslint/parser": "^6.14.0",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.16",
    "postcss": "^8.4.32",
    "tailwindcss": "^3.4.0",
    "typescript": "^5.3.3",
    "vite": "^5.0.10"
  }
}

// frontend/tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}

// frontend/tsconfig.node.json
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}

// frontend/vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  server: {
    port: 5173,
    host: true,
    watch: {
      usePolling: true
    }
  }
});

// frontend/postcss.config.js
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

// frontend/tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ["./src/**/*.{js,jsx,ts,tsx}"],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#f0f9ff',
          100: '#e0f2fe',
          200: '#bae6fd',
          300: '#7dd3fc',
          400: '#38bdf8',
          500: '#0ea5e9',
          600: '#0284c7',
          700: '#0369a1',
          800: '#075985',
          900: '#0c4a6e',
        },
      },
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
      }
    },
  },
  plugins: [],
}

// frontend/.env
VITE_WS_URL=ws://localhost:3001
VITE_API_URL=http://localhost:3001

// frontend/index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Medical Transport Marketplace</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

// frontend/src/types/index.ts
export interface Driver {
  id: string;
  name: string;
  vehicle: string;
  photo: string;
  wheelchairCertified: boolean;
  rating: number;
  coordinates: Coordinates;
  scheduledTrips: TransportRequest[];
  status: 'available' | 'busy' | 'offline';
  lastUpdated: string;
}

export interface TransportRequest {
  id: string;
  scheduledTime: string;
  distance: number;
  coordinates: Coordinates;
  address: string;
  phone: string;
  requiresWheelchair: boolean;
  insuranceCarrier: InsuranceCarrier;
  status: RequestStatus;
  createdAt: string;
  payment?: number;
  assignedDriver?: string;
}

export interface Coordinates {
  lat: number;
  lng: number;
}

export type InsuranceCarrier = 'Medicare' | 'BlueShield' | 'Medicaid' | 'Private';
export type RequestStatus = 'available' | 'assigned' | 'completed' | 'cancelled';

export interface Metrics {
  requestVolume: number;
  activeDrivers: number;
  nearbyDrivers: number;
}

export interface WebSocketMessage {
  type: MessageType;
  requests?: TransportRequest[];
  request?: TransportRequest;
  metrics?: Metrics;
  requestId?: string;
  driverId?: string;
  driver?: Driver;
}

export type MessageType =
  | 'initial'
  | 'new_request'
  | 'metrics_update'
  | 'request_assigned'
  | 'driver_update'
  | 'accept_request';

// frontend/src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

const rootElement = document.getElementById('root');
if (!rootElement) throw new Error('Failed to find the root element');

ReactDOM.createRoot(rootElement).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);

// frontend/src/App.tsx
import React from 'react';
import TransportMarketplace from './components/TransportMarketplace';

const App: React.FC = () => {
  return (
    <div>
      <TransportMarketplace />
    </div>
  );
};

export default App;

// frontend/src/index.css
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --primary-gradient: linear-gradient(to right bottom, #0ea5e9, #3b82f6);
  --card-gradient: linear-gradient(to right bottom, #1e293b, #0f172a);
}

body {
  @apply bg-gradient-to-br from-gray-900 via-gray-800 to-gray-900 text-white;
  min-height: 100vh;
}

.glass-card {
  background: rgba(30, 41, 59, 0.7);
  backdrop-filter: blur(12px);
  border: 1px solid rgba(255, 255, 255, 0.1);
  box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
}

.gradient-text {
  background: var(--primary-gradient);
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
}

.gradient-border {
  position: relative;
  background: var(--primary-gradient);
  padding: 1px;
  border-radius: 0.5rem;
}

.gradient-border > * {
  background: var(--card-gradient);
  border-radius: 0.5rem;
}

// frontend/src/components/ui/card.tsx
import React, { HTMLAttributes } from 'react';

interface CardProps extends HTMLAttributes<HTMLDivElement> {
  className?: string;
}

export function Card({ className = '', ...props }: CardProps) {
  return (
    <div
      className={`glass-card rounded-xl transition-all duration-300 ${className}`}
      {...props}
    />
  );
}

export function CardHeader({ className = '', ...props }: CardProps) {
  return <div className={`p-6 ${className}`} {...props} />;
}

export function CardTitle({ className = '', ...props }: CardProps) {
  return <h3 className={`text-lg font-semibold leading-none tracking-tight ${className}`} {...props} />;
}

export function CardContent({ className = '', ...props }: CardProps) {
  return <div className={`p-6 pt-0 ${className}`} {...props} />;
}

// frontend/src/components/MetricCard.tsx
import React from 'react';
import { LucideIcon } from 'lucide-react';
import { Card, CardHeader, CardTitle, CardContent } from './ui/card';

interface MetricCardProps {
  title: string;
  value: number;
  icon: LucideIcon;
  gradient: string;
}

const MetricCard: React.FC<MetricCardProps> = ({ title, value, icon: Icon, gradient }) => {
  return (
    <Card className={`${gradient} border-none text-white hover:scale-105 transition-transform duration-300`}>
      <CardHeader className="pb-2">
        <CardTitle className="text-lg flex items-center gap-2">
          <Icon className="w-5 h-5" />
          {title}
        </CardTitle>
      </CardHeader>
      <CardContent>
        <span className="text-4xl font-bold">{value}</span>
      </CardContent>
    </Card>
  );
};

export default MetricCard;

// frontend/src/components/TransportMarketplace.tsx
import React, { useState, useEffect } from 'react';
import { AlertCircle, Clock, MapPin, DollarSign, Phone, Car, Truck } from 'lucide-react';
import { Card, CardContent } from './ui/card';
import MetricCard from './MetricCard';
import type { TransportRequest, Metrics, WebSocketMessage } from '../types';

interface RequestCardProps {
  request: TransportRequest;
  isAssigned?: boolean;
  onAssign?: (request: TransportRequest) => void;
}

const RequestCard: React.FC<RequestCardProps> = ({ request, isAssigned = false, onAssign }) => (
  <Card className={`
    gradient-border hover:scale-102 transition-all duration-300
    ${isAssigned ? 'opacity-75' : ''}
  `}>
    <CardContent className="p-4">
      <div className="flex justify-between items-start mb-4">
        <div>
          <p className="text-lg font-semibold gradient-text">
            {new Date(request.scheduledTime).toLocaleTimeString()}
          </p>
          <p className="text-sm text-blue-400">{request.insuranceCarrier}</p>
        </div>
        <div className="flex items-center gap-2">
          {request.requiresWheelchair && (
            <span className="bg-blue-900 text-blue-200 px-2 py-1 rounded-full flex items-center gap-1">
              <Truck className="w-4 h-4" />
            </span>
          )}
          <span className="bg-green-900 text-green-200 px-2 py-1 rounded-full">
            ${request.payment}
          </span>
        </div>
      </div>

      <div className="space-y-2 mb-4">
        <p className="flex items-center gap-2 text-gray-300">
          <MapPin className="w-4 h-4" />
          <span className="text-sm">{request.address}</span>
        </p>
        <p className="flex items-center gap-2 text-gray-300">
          <Phone className="w-4 h-4" />
          <span className="text-sm">{request.phone}</span>
        </p>
        <p className="flex items-center gap-2 text-gray-300">
          <AlertCircle className="w-4 h-4" />
          <span className="text-sm">{request.distance.toFixed(1)} miles away</span>
        </p>
      </div>

      {!isAssigned && onAssign && (
        <button
          onClick={() => onAssign(request)}
          className="w-full bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-500 hover:to-blue-600
                   text-white py-2 px-4 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed
                   transition-all duration-300 transform hover:translate-y-[-2px]"
        >
          Accept Request
        </button>
      )}
    </CardContent>
  </Card>
);

const TransportMarketplace: React.FC = () => {
  const [metrics, setMetrics] = useState<Metrics>({
    requestVolume: 0,
    activeDrivers: 0,
    nearbyDrivers: 0
  });

  const [availableRequests, setAvailableRequests] = useState<TransportRequest[]>([]);
  const [assignedRequests, setAssignedRequests] = useState<TransportRequest[]>([]);
  const [ws, setWs] = useState<WebSocket | null>(null);

  useEffect(() => {
    const socket = new WebSocket(import.meta.env.VITE_WS_URL || 'ws://localhost:3001');

    socket.onopen = () => {
      console.log('Connected to server');
    };

    socket.onmessage = (event: MessageEvent) => {
      const data: WebSocketMessage = JSON.parse(event.data);

      switch (data.type) {
        case 'initial':
          if (data.requests) {
            setAvailableRequests(data.requests.filter(r => r.status === 'available'));
          }
          if (data.metrics) {
            setMetrics(data.metrics);
          }
          break;

        case 'new_request':
          if (data.request) {
            setAvailableRequests(prev => [...prev, data.request!]);
          }
          break;

        case 'metrics_update':
          if (data.metrics) {
            setMetrics(data.metrics);
          }
          break;

        case 'request_assigned':
          if (data.requestId) {
            const request = availableRequests.find(r => r.id === data.requestId);
            if (request) {
              setAssignedRequests(prev => [...prev, request]);
              setAvailableRequests(prev => prev.filter(r => r.id !== data.requestId));
            }
          }
          break;
      }
    };

    setWs(socket);

    return () => {
      socket.close();
    };
  }, [availableRequests]);

  const handleAssignRequest = (request: TransportRequest) => {
    if (ws) {
      ws.send(JSON.stringify({
        type: 'accept_request',
        requestId: request.id
      }));
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-900 p-6">
      <div className="max-w-7xl mx-auto space-y-8">
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
          <MetricCard
            title="Request Volume (12h)"
            value={metrics.requestVolume}
            icon={Clock}
            gradient="bg-gradient-to-br from-blue-600 to-blue-700"
          />
          <MetricCard
            title="Active Drivers"
            value={metrics.activeDrivers}
            icon={Car}
            gradient="bg-gradient-to-br from-purple-600 to-purple-700"
          />
          <MetricCard
            title="Nearby Drivers"
            value={metrics.nearbyDrivers}
            icon={MapPin}
            gradient="bg-gradient-to-br from-indigo-600 to-indigo-700"
          />
        </div>

        <div>
          <h2 className="text-2xl font-bold mb-4 gradient-text">Available Requests</h2>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {availableRequests.map(request => (
              <RequestCard
                key={request.id}
                request={request}
                onAssign={handleAssignRequest}
              />
            ))}
          </div>
        </div>

        <div>
          <h2 className="text-2xl font-bold mb-4 gradient-text">My Scheduled Trips</h2>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {assignedRequests.map(request => (
              <RequestCard
                key={request.id}
                request={request}
                isAssigned={true}
              />
            ))}
          </div>
        </div>
      </div>
    </div>
  );
};

export default TransportMarketplace;

// backend/package.json
{
  "name": "medical-transport-backend",
  "version": "1.0.0",
  "main": "dist/server.js",
  "scripts": {
    "start": "node dist/server.js",
    "dev": "ts-node-dev --respawn src/server.ts",
    "build": "tsc",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "express": "^4.18.2",
    "ws": "^8.16.0",
    "uuid": "^9.0.1",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "ioredis": "^5.3.2",
    "@faker-js/faker": "^8.3.1"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/ws": "^8.5.10",
    "@types/uuid": "^9.0.7",
    "@types/cors": "^2.8.17",
    "@typescript-eslint/eslint-plugin": "^6.14.0",
    "@typescript-eslint/parser": "^6.14.0",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.3.3"
  }
}

// backend/tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["es2020"],
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "moduleResolution": "node",
    "resolveJsonModule": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}

// backend/.env
PORT=3001
CORS_ORIGIN=http://localhost:5173
REDIS_HOST=localhost
REDIS_PORT=6379
NODE_ENV=development

// backend/src/types/index.ts
export interface Driver {
  id: string;
  name: string;
  vehicle: string;
  photo: string;
  wheelchairCertified: boolean;
  rating: number;
  coordinates: Coordinates;
  scheduledTrips: TransportRequest[];
  status: 'available' | 'busy' | 'offline';
  lastUpdated: string;
  ws?: WebSocket;
}

export interface TransportRequest {
  id: string;
  scheduledTime: string;
  distance: number;
  coordinates: Coordinates;
  address: string;
  phone: string;
  requiresWheelchair: boolean;
  insuranceCarrier: InsuranceCarrier;
  status: RequestStatus;
  createdAt: string;
  payment?: number;
  assignedDriver?: string;
}

export interface Coordinates {
  lat: number;
  lng: number;
}

export type InsuranceCarrier = 'Medicare' | 'BlueShield' | 'Medicaid' | 'Private';
export type RequestStatus = 'available' | 'assigned' | 'completed' | 'cancelled';

export interface Metrics {
  requestVolume: number;
  activeDrivers: number;
  nearbyDrivers: number;
}

export interface WebSocketMessage {
  type: MessageType;
  requests?: TransportRequest[];
  request?: TransportRequest;
  metrics?: Metrics;
  requestId?: string;
  driverId?: string;
  driver?: Driver;
}

export type MessageType =
  | 'initial'
  | 'new_request'
  | 'metrics_update'
  | 'request_assigned'
  | 'driver_update'
  | 'accept_request';

// backend/src/types/driver-metrics.ts
export interface DriverMetrics {
  completedTrips: number;
  cancelledTrips: number;
  totalRatings: number;
  ratingSum: number;
  onTimePercentage: number;
  acceptanceRate: number;
  wheelchairTripsCompleted: number;
  averageResponseTime: number;  // in seconds
  lastUpdated: string;
}

export interface TripCompletion {
  requestId: string;
  scheduledTime: string;
  completionTime: string;
  wasOnTime: boolean;
  patientRating?: number;
  patientFeedback?: string;
}

// backend/src/services/redis-client.ts
import Redis from 'ioredis';
import type { Driver, TransportRequest, Metrics } from '../types';

class RedisClient {
  private client: Redis;
  private subscriber: Redis;

  constructor() {
    this.client = new Redis({
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT || '6379'),
    });

    this.subscriber = this.client.duplicate();

    this.client.on('error', (err: Error) => console.error('Redis Client Error:', err));
    this.client.on('connect', () => console.log('Redis Client Connected'));
  }

  async publish(channel: string, message: unknown): Promise<number> {
    return await this.client.publish(channel, JSON.stringify(message));
  }

  async subscribe(channel: string, callback: (data: unknown) => void): Promise<void> {
    await this.subscriber.subscribe(channel);
    this.subscriber.on('message', (ch: string, message: string) => {
      if (ch === channel) {
        callback(JSON.parse(message));
      }
    });
  }

  async addDriver(driver: Driver): Promise<void> {
    const driverData = { ...driver };
    delete driverData.ws; // Remove WebSocket instance before storing
    await this.client.hset(`driver:${driver.id}`, driverData as any);
    await this.client.sadd('active_drivers', driver.id);
  }

  async removeDriver(driverId: string): Promise<void> {
    await this.client.srem('active_drivers', driverId);
    await this.client.del(`driver:${driverId}`);
  }

  async getDriver(driverId: string): Promise<Driver | null> {
    const driver = await this.client.hgetall(`driver:${driverId}`);
    return driver ? (driver as unknown as Driver) : null;
  }

  async getAllDrivers(): Promise<Driver[]> {
    const driverIds = await this.client.smembers('active_drivers');
    const drivers = await Promise.all(
      driverIds.map(id => this.getDriver(id))
    );
    return drivers.filter((d): d is Driver => d !== null);
  }

  async addRequest(request: TransportRequest): Promise<void> {
    await this.client.hset(`request:${request.id}`, request as any);
    await this.client.sadd('active_requests', request.id);
  }

  async updateRequestStatus(requestId: string, status: string): Promise<void> {
    await this.client.hset(`request:${requestId}`, 'status', status);
  }

  async getRequest(requestId: string): Promise<TransportRequest | null> {
    const request = await this.client.hgetall(`request:${requestId}`);
    return request ? (request as unknown as TransportRequest) : null;
  }

  async getAllRequests(): Promise<TransportRequest[]> {
    const requestIds = await this.client.smembers('active_requests');
    const requests = await Promise.all(
      requestIds.map(id => this.getRequest(id))
    );
    return requests.filter((r): r is TransportRequest => r !== null);
  }

  async updateMetrics(metrics: Metrics): Promise<void> {
    await this.client.hmset('metrics', metrics as any);
  }

  async getMetrics(): Promise<Metrics> {
    const metrics = await this.client.hgetall('metrics');
    return {
      requestVolume: parseInt(metrics.requestVolume || '0'),
      activeDrivers: parseInt(metrics.activeDrivers || '0'),
      nearbyDrivers: parseInt(metrics.nearbyDrivers || '0')
    };
  }
}

export default new RedisClient();

// backend/src/services/driver-metrics.ts
import { Redis } from 'ioredis';
import type { Driver, DriverMetrics, TripCompletion } from '../types';

export class DriverMetricsService {
  constructor(private redis: Redis) {}

  private getDriverMetricsKey(driverId: string): string {
    return `driver:${driverId}:metrics`;
  }

  private getDriverHistoryKey(driverId: string): string {
    return `driver:${driverId}:history`;
  }

  async updateDriverRating(driverId: string, rating: number): Promise<void> {
    const metricsKey = this.getDriverMetricsKey(driverId);
    await this.redis.hincr(metricsKey, 'totalRatings', 1);
    await this.redis.hincr(metricsKey, 'ratingSum', rating);

    // Update the average rating in the main driver hash
    const metrics = await this.getDriverMetrics(driverId);
    const avgRating = metrics.ratingSum / metrics.totalRatings;
    await this.redis.hset(`driver:${driverId}`, 'rating', avgRating.toFixed(1));
  }

  async recordTripCompletion(driverId: string, completion: TripCompletion): Promise<void> {
    const metricsKey = this.getDriverMetricsKey(driverId);
    const historyKey = this.getDriverHistoryKey(driverId);

    // Store the completion record in the driver's history
    await this.redis.lpush(historyKey, JSON.stringify(completion));
    // Keep last 100 trips only
    await this.redis.ltrim(historyKey, 0, 99);

    // Update metrics
    await this.redis.hincrby(metricsKey, 'completedTrips', 1);
    if (completion.wasOnTime) {
      await this.redis.hincrby(metricsKey, 'onTimeTrips', 1);
    }

    if (completion.patientRating) {
      await this.updateDriverRating(driverId, completion.patientRating);
    }

    // Update overall metrics
    const metrics = await this.getDriverMetrics(driverId);
    const onTimePercentage = (metrics.onTimeTrips / metrics.completedTrips) * 100;
    await this.redis.hset(metricsKey, 'onTimePercentage', onTimePercentage.toFixed(1));
  }

  async getDriverMetrics(driverId: string): Promise<DriverMetrics> {
    const metricsKey = this.getDriverMetricsKey(driverId);
    const metrics = await this.redis.hgetall(metricsKey);

    return {
      completedTrips: parseInt(metrics.completedTrips || '0'),
      cancelledTrips: parseInt(metrics.cancelledTrips || '0'),
      totalRatings: parseInt(metrics.totalRatings || '0'),
      ratingSum: parseFloat(metrics.ratingSum || '0'),
      onTimePercentage: parseFloat(metrics.onTimePercentage || '0'),
      acceptanceRate: parseFloat(metrics.acceptanceRate || '0'),
      wheelchairTripsCompleted: parseInt(metrics.wheelchairTripsCompleted || '0'),
      averageResponseTime: parseFloat(metrics.averageResponseTime || '0'),
      lastUpdated: metrics.lastUpdated || new Date().toISOString()
    };
  }

  async getDriverHistory(driverId: string, limit: number = 10): Promise<TripCompletion[]> {
    const historyKey = this.getDriverHistoryKey(driverId);
    const history = await this.redis.lrange(historyKey, 0, limit - 1);
    return history.map(item => JSON.parse(item));
  }

  async calculateDriverScore(driverId: string): Promise<number> {
    const metrics = await this.getDriverMetrics(driverId);

    const weights = {
      rating: 0.3,
      onTime: 0.25,
      acceptance: 0.2,
      experience: 0.15,
      responseTime: 0.1
    };

    const ratingScore = metrics.ratingSum / (metrics.totalRatings * 5);
    const onTimeScore = metrics.onTimePercentage / 100;
    const acceptanceScore = metrics.acceptanceRate / 100;
    const experienceScore = Math.min(metrics.completedTrips / 1000, 1);
    const responseScore = Math.max(0, 1 - (metrics.averageResponseTime / 60));

    const totalScore = (
      (ratingScore * weights.rating) +
      (onTimeScore * weights.onTime) +
      (acceptanceScore * weights.acceptance) +
      (experienceScore * weights.experience) +
      (responseScore * weights.responseTime)
    );

    return Number(totalScore.toFixed(4));
  }

  async initializeDriverMetrics(driverId: string): Promise<void> {
    const metricsKey = this.getDriverMetricsKey(driverId);
    const initialMetrics: DriverMetrics = {
      completedTrips: 0,
      cancelledTrips: 0,
      totalRatings: 0,
      ratingSum: 0,
      onTimePercentage: 100,
      acceptanceRate: 100,
      wheelchairTripsCompleted: 0,
      averageResponseTime: 0,
      lastUpdated: new Date().toISOString()
    };

    await this.redis.hmset(metricsKey, initialMetrics as any);
  }
}

// backend/src/services/data-generator.ts
import { v4 as uuidv4 } from 'uuid';
import { faker } from '@faker-js/faker';
import redisClient from './redis-client';
import type { Driver, TransportRequest, InsuranceCarrier } from '../types';

export class DataGenerator {
  constructor() {
    this.generateInitialData();
    this.startGenerators();
  }